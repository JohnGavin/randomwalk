[{"name":"app.R","content":"# Async Random Walk Simulation Dashboard\n# This dashboard demonstrates parallel processing capabilities using crew workers\n\n# Load required packages\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(randomwalk)\n\n# Define UI\nui <- fluidPage(\n  titlePanel(\"Async Random Walk Simulation Dashboard\"),\n\n  sidebarLayout(\n    # Sidebar with input controls\n    sidebarPanel(\n      width = 3,\n\n      h4(\"Simulation Parameters\"),\n      p(\"Configure the random walk simulation parameters below.\"),\n\n      hr(),\n\n      # ASYNC PARAMETER - Number of workers\n      sliderInput(\n        \"workers\",\n        \"Number of Workers:\",\n        min = 0,\n        max = 4,\n        value = 2,\n        step = 1,\n        ticks = FALSE\n      ),\n      helpText(\n        HTML(\"<b>0 = Sync mode<\/b> (sequential)<br>\",\n             \"<b>1+ = Async mode<\/b> (parallel)<br>\",\n             \"More workers may improve performance\")\n      ),\n\n      sliderInput(\n        \"grid_size\",\n        \"Grid Size:\",\n        min = 5,\n        max = 50,\n        value = 20,\n        step = 1,\n        ticks = FALSE\n      ),\n      helpText(\"Size of the square grid (5-50)\"),\n\n      sliderInput(\n        \"n_walkers\",\n        \"Number of Walkers:\",\n        min = 1,\n        max = 20,\n        value = 6,\n        step = 1,\n        ticks = FALSE\n      ),\n      helpText(\"Number of simultaneous random walkers (1-20)\"),\n\n      selectInput(\n        \"neighborhood\",\n        \"Neighborhood Type:\",\n        choices = c(\n          \"4-neighborhood (N, S, E, W)\" = \"4-hood\",\n          \"8-neighborhood (incl. diagonals)\" = \"8-hood\"\n        ),\n        selected = \"4-hood\"\n      ),\n\n      selectInput(\n        \"boundary\",\n        \"Boundary Behavior:\",\n        choices = c(\n          \"Terminate at edge\" = \"terminate\",\n          \"Wrap around (torus)\" = \"wrap\"\n        ),\n        selected = \"terminate\"\n      ),\n\n      sliderInput(\n        \"max_steps\",\n        \"Max Steps per Walker:\",\n        min = 1000,\n        max = 20000,\n        value = 10000,\n        step = 1000,\n        ticks = FALSE\n      ),\n      helpText(\"Maximum steps before walker stops (1k-20k)\"),\n\n      hr(),\n\n      actionButton(\n        \"run_sim\",\n        \"Run Simulation\",\n        class = \"btn-primary btn-lg\",\n        width = \"100%\",\n        icon = icon(\"play\")\n      ),\n\n      br(), br(),\n\n      actionButton(\n        \"reset\",\n        \"Reset to Defaults\",\n        class = \"btn-secondary\",\n        width = \"100%\",\n        icon = icon(\"rotate-left\")\n      ),\n\n      hr(),\n\n      # Status display\n      div(\n        id = \"status_box\",\n        style = \"padding: 10px; border-radius: 5px; background-color: #f8f9fa;\",\n        h5(\"Status\", style = \"margin-top: 0;\"),\n        textOutput(\"status_text\")\n      )\n    ),\n\n    # Main panel with tabbed output\n    mainPanel(\n      width = 9,\n\n      tabsetPanel(\n        id = \"output_tabs\",\n        type = \"pills\",\n\n        # Performance Tab (NEW for async)\n        tabPanel(\n          \"Performance\",\n          icon = icon(\"gauge-high\"),\n          br(),\n          h4(\"Async Performance Metrics\"),\n          p(\"Compare execution time between sync and async modes.\"),\n          tableOutput(\"perf_table\"),\n          hr(),\n          h5(\"Execution Mode\"),\n          p(textOutput(\"mode_info\")),\n          hr(),\n          h5(\"Performance Analysis\"),\n          p(textOutput(\"perf_analysis\"))\n        ),\n\n        # Grid State Tab\n        tabPanel(\n          \"Grid State\",\n          icon = icon(\"table-cells\"),\n          br(),\n          h4(\"Final Grid Visualization\"),\n          p(\"Black squares represent pixels visited by random walkers.\"),\n          plotOutput(\"grid_plot\", height = \"600px\"),\n          hr(),\n          p(class = \"text-muted\", \"Generated using plot_grid() from the randomwalk package\")\n        ),\n\n        # Walker Paths Tab\n        tabPanel(\n          \"Walker Paths\",\n          icon = icon(\"route\"),\n          br(),\n          h4(\"Individual Walker Trajectories\"),\n          p(\"Green squares mark starting positions, red squares show where walkers terminated.\"),\n          plotOutput(\"paths_plot\", height = \"600px\"),\n          hr(),\n          p(class = \"text-muted\", \"Generated using plot_walker_paths() from the randomwalk package\")\n        ),\n\n        # Statistics Tab\n        tabPanel(\n          \"Statistics\",\n          icon = icon(\"chart-line\"),\n          br(),\n          h4(\"Simulation Metrics\"),\n          tableOutput(\"stats_table\"),\n          hr(),\n          h5(\"Coverage Analysis\"),\n          p(textOutput(\"coverage_analysis\")),\n          hr(),\n          h5(\"Walker Summary\"),\n          tableOutput(\"walker_summary\")\n        ),\n\n        # Raw Data Tab\n        tabPanel(\n          \"Raw Data\",\n          icon = icon(\"database\"),\n          br(),\n          h4(\"Detailed Walker Information\"),\n          p(\"Complete data for each walker in the simulation.\"),\n          dataTableOutput(\"walker_data\"),\n          hr(),\n          h4(\"Grid Information\"),\n          tableOutput(\"grid_info\")\n        ),\n\n        # About Tab\n        tabPanel(\n          \"About\",\n          icon = icon(\"info-circle\"),\n          br(),\n          h4(\"About This Async Dashboard\"),\n          p(\"This interactive dashboard demonstrates the randomwalk package's async/parallel capabilities using crew workers and WebAssembly.\"),\n\n          h5(\"How Async Mode Works\"),\n          tags$ul(\n            tags$li(strong(\"Sync Mode (workers=0):\"), \" Walkers processed sequentially\"),\n            tags$li(strong(\"Async Mode (workers>0):\"), \" Walkers processed in parallel by crew workers\"),\n            tags$li(strong(\"Static Snapshots:\"), \" Workers use frozen grid state (no real-time sync)\"),\n            tags$li(strong(\"Independent Execution:\"), \" Each worker processes walkers independently\")\n          ),\n\n          h5(\"Expected Performance\"),\n          tags$ul(\n            tags$li(\"1 worker: Similar to sync mode\"),\n            tags$li(\"2 workers: ~1.5x speedup (target)\"),\n            tags$li(\"4 workers: ~2-3x speedup (depends on workload)\"),\n            tags$li(\"Speedup limited by walker termination times and overhead\")\n          ),\n\n          h5(\"Trade-offs\"),\n          tags$ul(\n            tags$li(tags$b(\"Pro:\"), \" Faster execution with multiple workers\"),\n            tags$li(tags$b(\"Pro:\"), \" Simple, reliable architecture\"),\n            tags$li(tags$b(\"Con:\"), \" Results may differ from sync mode (acceptable)\"),\n            tags$li(tags$b(\"Con:\"), \" Workers don't see real-time updates from other workers\")\n          ),\n\n          h5(\"References\"),\n          tags$ul(\n            tags$li(tags$a(href = \"https://github.com/JohnGavin/randomwalk\", \"randomwalk GitHub Repository\")),\n            tags$li(tags$a(href = \"https://wlandau.github.io/crew/\", \"crew: A Distributed Worker Launcher\")),\n            tags$li(tags$a(href = \"https://posit-dev.github.io/r-shinylive/\", \"Shinylive Documentation\"))\n          )\n        )\n      )\n    )\n  )\n)\n\n# Define server logic\nserver <- function(input, output, session) {\n\n  # Reactive value to store simulation result\n  sim_result <- reactiveVal(NULL)\n\n  # Reactive value for status messages\n  status_msg <- reactiveVal(\"Ready to run simulation\")\n\n  # Run simulation when button clicked\n  observeEvent(input$run_sim, {\n    mode_text <- if (input$workers == 0) \"sync\" else sprintf(\"async (%d workers)\", input$workers)\n    status_msg(sprintf(\"Running simulation in %s mode...\", mode_text))\n\n    tryCatch({\n      # Validate inputs\n      if (input$n_walkers > (0.6 * input$grid_size^2)) {\n        showNotification(\n          \"Too many walkers for grid size. Maximum is 60% of grid cells.\",\n          type = \"warning\",\n          duration = 5\n        )\n        status_msg(\"Error: Too many walkers for grid size\")\n        return(NULL)\n      }\n\n      # Run the simulation using randomwalk package with workers parameter\n      result <- randomwalk::run_simulation(\n        grid_size = input$grid_size,\n        n_walkers = input$n_walkers,\n        workers = input$workers,        # ASYNC PARAMETER\n        neighborhood = input$neighborhood,\n        boundary = input$boundary,\n        max_steps = input$max_steps,\n        verbose = FALSE\n      )\n\n      # Store result\n      sim_result(result)\n\n      # Update status\n      status_msg(sprintf(\n        \"Simulation complete (%s mode)! %d steps, %.1f%% coverage in %.2fs\",\n        mode_text,\n        result$statistics$total_steps,\n        result$statistics$black_percentage,\n        result$statistics$elapsed_time_secs\n      ))\n\n      # Show success notification\n      showNotification(\n        sprintf(\"Simulation completed in %.2f seconds!\", result$statistics$elapsed_time_secs),\n        type = \"message\",\n        duration = 3\n      )\n\n    }, error = function(e) {\n      status_msg(paste(\"Error:\", e$message))\n      showNotification(\n        paste(\"Simulation failed:\", e$message),\n        type = \"error\",\n        duration = 10\n      )\n    })\n  })\n\n  # Reset parameters\n  observeEvent(input$reset, {\n    updateSliderInput(session, \"workers\", value = 2)\n    updateSliderInput(session, \"grid_size\", value = 20)\n    updateSliderInput(session, \"n_walkers\", value = 6)\n    updateSelectInput(session, \"neighborhood\", selected = \"4-hood\")\n    updateSelectInput(session, \"boundary\", selected = \"terminate\")\n    updateSliderInput(session, \"max_steps\", value = 10000)\n    status_msg(\"Parameters reset to defaults\")\n\n    showNotification(\n      \"Parameters reset to default values\",\n      type = \"message\",\n      duration = 2\n    )\n  })\n\n  # Render status text\n  output$status_text <- renderText({\n    status_msg()\n  })\n\n  # ASYNC PERFORMANCE TABLE\n  output$perf_table <- renderTable({\n    req(sim_result())\n    stats <- sim_result()$statistics\n    params <- sim_result()$parameters\n\n    data.frame(\n      Metric = c(\n        \"Execution Mode\",\n        \"Number of Workers\",\n        \"Elapsed Time\",\n        \"Total Steps\",\n        \"Steps per Second\",\n        \"Black Pixels Created\"\n      ),\n      Value = c(\n        ifelse(params$workers == 0, \"Sync (Sequential)\", sprintf(\"Async (Parallel - %d workers)\", params$workers)),\n        params$workers,\n        sprintf(\"%.3f seconds\", stats$elapsed_time_secs),\n        format(stats$total_steps, big.mark = \",\"),\n        format(round(stats$total_steps / stats$elapsed_time_secs), big.mark = \",\"),\n        stats$black_pixels\n      )\n    )\n  }, striped = TRUE, hover = TRUE, bordered = TRUE)\n\n  # Mode information\n  output$mode_info <- renderText({\n    req(sim_result())\n    params <- sim_result()$parameters\n\n    if (params$workers == 0) {\n      \"Running in SYNC mode: Walkers are processed sequentially in round-robin fashion. This produces deterministic, reproducible results.\"\n    } else {\n      sprintf(\n        \"Running in ASYNC mode with %d worker%s: Walkers are distributed across parallel workers. Workers use static grid snapshots, so results may differ from sync mode. This is expected behavior.\",\n        params$workers,\n        ifelse(params$workers == 1, \"\", \"s\")\n      )\n    }\n  })\n\n  # Performance analysis\n  output$perf_analysis <- renderText({\n    req(sim_result())\n    stats <- sim_result()$statistics\n    params <- sim_result()$parameters\n\n    if (params$workers == 0) {\n      sprintf(\n        \"Sync mode completed %d walkers in %.3f seconds (%.1f walkers/second). To test async performance, increase the number of workers and re-run.\",\n        stats$total_walkers,\n        stats$elapsed_time_secs,\n        stats$total_walkers / stats$elapsed_time_secs\n      )\n    } else {\n      # Estimate theoretical speedup (actual depends on walker termination patterns)\n      theoretical_speedup <- min(params$workers, stats$total_walkers)\n\n      sprintf(\n        \"Async mode with %d workers completed %d walkers in %.3f seconds. Theoretical maximum speedup is %.1fx (limited by %d workers and %d walkers). Actual speedup depends on walker termination patterns and parallelization overhead. Try comparing with sync mode (workers=0) to measure actual speedup.\",\n        params$workers,\n        stats$total_walkers,\n        stats$elapsed_time_secs,\n        theoretical_speedup,\n        params$workers,\n        stats$total_walkers\n      )\n    }\n  })\n\n  # Render grid plot\n  output$grid_plot <- renderPlot({\n    req(sim_result())\n    randomwalk::plot_grid(sim_result())\n  })\n\n  # Render walker paths plot\n  output$paths_plot <- renderPlot({\n    req(sim_result())\n    randomwalk::plot_walker_paths(sim_result())\n  })\n\n  # Render statistics table\n  output$stats_table <- renderTable({\n    req(sim_result())\n    stats <- sim_result()$statistics\n\n    data.frame(\n      Metric = c(\n        \"Total Steps\",\n        \"Final Black Pixels\",\n        \"Final Black Percentage\",\n        \"Grid Size\",\n        \"Number of Walkers\",\n        \"Elapsed Time (sec)\"\n      ),\n      Value = c(\n        format(stats$total_steps, big.mark = \",\"),\n        format(stats$black_pixels, big.mark = \",\"),\n        sprintf(\"%.2f%%\", stats$black_percentage),\n        sprintf(\"%d × %d\", stats$grid_size, stats$grid_size),\n        stats$total_walkers,\n        sprintf(\"%.3f\", stats$elapsed_time_secs)\n      )\n    )\n  }, striped = TRUE, hover = TRUE, bordered = TRUE)\n\n  # Coverage analysis text\n  output$coverage_analysis <- renderText({\n    req(sim_result())\n    stats <- sim_result()$statistics\n\n    total_cells <- stats$grid_size^2\n    black_cells <- stats$black_pixels\n    coverage_pct <- stats$black_percentage\n\n    sprintf(\n      \"The simulation covered %d out of %d grid cells (%.2f%%). On average, %.1f steps were taken per black pixel created.\",\n      black_cells,\n      total_cells,\n      coverage_pct,\n      stats$total_steps / black_cells\n    )\n  })\n\n  # Walker summary table\n  output$walker_summary <- renderTable({\n    req(sim_result())\n    walkers <- sim_result()$walkers\n\n    data.frame(\n      Statistic = c(\n        \"Total Walkers\",\n        \"Average Steps\",\n        \"Min Steps\",\n        \"Max Steps\",\n        \"Completed Walkers\"\n      ),\n      Value = c(\n        length(walkers),\n        sprintf(\"%.1f\", mean(sapply(walkers, function(w) w$steps))),\n        min(sapply(walkers, function(w) w$steps)),\n        max(sapply(walkers, function(w) w$steps)),\n        sum(sapply(walkers, function(w) !w$active))\n      )\n    )\n  }, striped = TRUE, hover = TRUE, bordered = TRUE)\n\n  # Walker data table\n  output$walker_data <- renderDataTable({\n    req(sim_result())\n    walkers <- sim_result()$walkers\n\n    # Format for display\n    walkers_display <- data.frame(\n      Walker = sapply(walkers, function(w) w$id),\n      Steps = sapply(walkers, function(w) w$steps),\n      Start_X = sapply(walkers, function(w) w$path[[1]][1]),\n      Start_Y = sapply(walkers, function(w) w$path[[1]][2]),\n      End_X = sapply(walkers, function(w) tail(w$path[[1]], 1)[1]),\n      End_Y = sapply(walkers, function(w) tail(w$path[[1]], 1)[2]),\n      Active = sapply(walkers, function(w) ifelse(w$active, \"Yes\", \"No\")),\n      Reason = sapply(walkers, function(w) w$termination_reason)\n    )\n\n    walkers_display\n  }, options = list(\n    pageLength = 10,\n    scrollX = TRUE,\n    dom = 'tip'\n  ))\n\n  # Grid info table\n  output$grid_info <- renderTable({\n    req(sim_result())\n    stats <- sim_result()$statistics\n    params <- sim_result()$parameters\n\n    data.frame(\n      Property = c(\n        \"Grid Dimensions\",\n        \"Total Cells\",\n        \"Black Cells\",\n        \"White Cells\",\n        \"Neighborhood Type\",\n        \"Boundary Behavior\",\n        \"Execution Mode\"\n      ),\n      Value = c(\n        sprintf(\"%d × %d\", stats$grid_size, stats$grid_size),\n        format(stats$grid_size^2, big.mark = \",\"),\n        format(stats$black_pixels, big.mark = \",\"),\n        format(stats$grid_size^2 - stats$black_pixels, big.mark = \",\"),\n        input$neighborhood,\n        input$boundary,\n        ifelse(params$workers == 0, \"Sync\", sprintf(\"Async (%d workers)\", params$workers))\n      )\n    )\n  }, striped = TRUE, hover = TRUE, bordered = TRUE)\n}\n\n# Run the application\nshinyApp(ui = ui, server = server)\n","type":"text"}]

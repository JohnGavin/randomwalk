% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/async_worker.R
\name{worker_step_walker}
\alias{worker_step_walker}
\title{Execute Walker Step (Worker)}
\usage{
worker_step_walker(
  walker,
  grid_state,
  worker_state,
  neighborhood = "4-hood",
  boundary = "terminate",
  max_steps = 10000L
)
}
\arguments{
\item{walker}{List. Walker object (from \code{create_walker()}).}

\item{grid_state}{List. Contains grid matrix and black_pixels set.}

\item{worker_state}{List. Worker state from \code{worker_init()}.}

\item{neighborhood}{Character. "4-hood" or "8-hood" (default: "4-hood").}

\item{boundary}{Character. "terminate" or "wrap" (default: "terminate").}

\item{max_steps}{Integer. Maximum steps before forced termination (default: 10000).}
}
\value{
Modified walker object after one step.
}
\description{
Executes one step of a walker using cached grid state.
This is the main work function executed by crew workers.
}
\details{
Performs one iteration of the random walk:
\enumerate{
\item Check for grid updates (refresh cache)
\item Move walker one step using \code{step_walker()}
\item Check termination using cached black pixels
}

The worker uses its local cache of black pixels to check termination
conditions. This avoids querying the main process on every step,
significantly reducing synchronization overhead.

Cache staleness is acceptable because:
\itemize{
\item Random walks are stochastic (small delays don't affect statistical properties)
\item Updates are broadcast immediately when walkers terminate
\item Worker checks for updates before each step
}
}
\examples{
\dontrun{
# Step a walker in a worker process
walker <- worker_step_walker(
  walker = walker,
  grid_state = grid_state,
  worker_state = worker_state,
  neighborhood = "4-hood",
  boundary = "terminate"
)
}

}
\seealso{
\code{\link{step_walker}}, \code{\link{check_termination}}
}

---
title: "Telemetry and Pipeline Statistics"
author: "randomwalk package"
date: today
format:
  html:
    code-fold: true
    code-summary: "Show code"
    toc: true
    toc-depth: 3
    number-sections: false
execute:
  echo: false
  message: false
  warning: false
  fig-width: 10
  fig-height: 6
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  fig.width = 10,
  fig.height = 6,
  collapse = TRUE,
  comment = "#>"
)

# Load required packages
library(knitr)
library(targets)
library(dplyr)
library(ggplot2)

# Set targets store path and script path to project root
# When pkgdown renders vignettes, it may change working directory
if (!dir.exists("_targets")) {
  # Try parent directory (when rendering from vignettes/)
  if (dir.exists("../_targets")) {
    targets::tar_config_set(store = "../_targets", script = "../_targets.R")
  }
}

# Helper function to format simulation statistics as a nice table
format_sim_stats <- function(stats) {
  # Validate that n_walkers/total_walkers exists and is positive
  n_walkers_value <- if (!is.null(stats$total_walkers) && is.numeric(stats$total_walkers)) {
    stopifnot("Number of walkers must be positive" = stats$total_walkers > 0)
    as.integer(stats$total_walkers)
  } else if (!is.null(stats$n_walkers) && is.numeric(stats$n_walkers)) {
    stopifnot("Number of walkers must be positive" = stats$n_walkers > 0)
    as.integer(stats$n_walkers)
  } else {
    stop("Statistics must contain total_walkers or n_walkers field")
  }

  # Get the correct field names for black pixels
  black_count <- if (!is.null(stats$black_pixels)) {
    stats$black_pixels
  } else if (!is.null(stats$final_black_count)) {
    stats$final_black_count
  } else {
    NA
  }

  black_pct <- if (!is.null(stats$black_percentage)) {
    stats$black_percentage
  } else if (!is.null(stats$final_black_percentage)) {
    stats$final_black_percentage
  } else {
    NA
  }

  elapsed <- if (!is.null(stats$elapsed_time_secs)) {
    stats$elapsed_time_secs
  } else if (!is.null(stats$elapsed_time)) {
    stats$elapsed_time
  } else {
    NA
  }

  data.frame(
    Metric = c(
      "Total Steps",
      "Final Black Pixels",
      "Final Black Percentage",
      "Grid Size",
      "Number of Walkers",
      "Elapsed Time (sec)"
    ),
    Value = c(
      format(stats$total_steps, big.mark = ","),
      format(black_count, big.mark = ","),
      sprintf("%.2f%%", black_pct),
      sprintf("%d × %d", stats$grid_size, stats$grid_size),
      as.character(n_walkers_value),
      sprintf("%.3f", elapsed)
    ),
    stringsAsFactors = FALSE
  )
}
```

# Overview

This vignette presents telemetry statistics and pipeline performance metrics for the `randomwalk` package, following best practices outlined in the package context documentation.

All tables, graphs, and statistics in this vignette are pre-computed using the `targets` pipeline and loaded via `tar_read()`. This ensures reproducibility and efficient vignette rendering.

# Package Information

```{r package-info}
pkg_info <- tar_read(package_info)

data.frame(
  Field = c("Package", "Version", "Title", "Generated"),
  Value = c(
    pkg_info$package,
    pkg_info$version,
    pkg_info$title,
    format(pkg_info$date, "%Y-%m-%d")
  )
) %>%
  kable(caption = "Package Metadata")
```

# Example Simulations

The targets pipeline includes example simulations to demonstrate package functionality and measure performance.

## Small Simulation (10×10 grid)

A compact simulation demonstrating basic random walk behavior:

```{r sim-small-stats}
stats_small <- tar_read(stats_small)
format_sim_stats(stats_small) %>%
  kable(caption = "Small Simulation Statistics", align = c("l", "r"))
```

```{r plot-small-grid, fig.cap="Small simulation: Final grid state showing walker paths"}
tar_read(plot_small_grid)
```

## Medium Simulation (20×20 grid)

A larger simulation with more walkers using 8-connected neighborhood and wrapping boundaries:

```{r sim-medium-stats}
stats_medium <- tar_read(stats_medium)
format_sim_stats(stats_medium) %>%
  kable(caption = "Medium Simulation Statistics", align = c("l", "r"))
```

```{r plot-medium-grid, fig.cap="Medium simulation: Complex patterns from 5 walkers"}
tar_read(plot_medium_grid)
```

## Large Simulation (30×30 grid) - High Coverage

This simulation is configured to achieve substantial grid coverage (target: >25% black pixels).
With a 30×30 grid (900 total pixels), this requires approximately 225+ black pixels.

Since walkers terminate when they touch a black neighbor, each walker typically creates 1 black pixel before stopping.
Therefore, to achieve >225 black pixels, the simulation uses 300 walkers.

```{r sim-large-stats}
stats_large <- tar_read(stats_large)

# Verify coverage meets target
coverage_pct <- stats_large$black_percentage
stopifnot("Large simulation must achieve >25% coverage" = coverage_pct > 25)

format_sim_stats(stats_large) %>%
  kable(caption = "Large Simulation Statistics", align = c("l", "r"))
```

```{r plot-large-grid, fig.cap="Large simulation: Extensive coverage with 300 walkers showing >25% black pixels", fig.width=10, fig.height=10}
tar_read(plot_large_grid)
```

The large simulation demonstrates the package's ability to handle many walkers simultaneously. The final grid state should show substantial black pixel coverage across the grid (>25%), with walkers terminating when they encounter black neighbors in the 8-connected neighborhood.

# Performance Comparison: Async vs Sync

This section demonstrates the empirical benefits of asynchronous (parallel) simulation compared to synchronous execution.

## Test Configuration

Both tests run identical simulations (25×25 grid, 8 walkers, 8-hood, wrap boundaries, 5000 max steps):
- **Synchronous**: `workers = 0` (single-threaded)
- **Asynchronous**: `workers = 4` (4 parallel workers)

```{r perf-comparison}
perf_sync <- tar_read(perf_sync)
perf_async <- tar_read(perf_async)

speedup <- perf_sync$elapsed / perf_async$elapsed

data.frame(
  Mode = c("Synchronous", "Asynchronous", "Speedup Factor"),
  `Elapsed Time` = c(
    sprintf("%.2f sec", perf_sync$elapsed),
    sprintf("%.2f sec", perf_async$elapsed),
    sprintf("%.2fx", speedup)
  ),
  `Coverage` = c(
    sprintf("%.2f%%", perf_sync$result$statistics$final_black_percentage),
    sprintf("%.2f%%", perf_async$result$statistics$final_black_percentage),
    "—"
  ),
  check.names = FALSE
) %>%
  kable(caption = "Performance Comparison: Synchronous vs Asynchronous Execution",
        align = c("l", "r", "r"))
```

### Performance Visualization

```{r perf-plot, fig.cap="Execution time comparison showing async speedup"}
perf_data <- data.frame(
  Mode = c("Sync", "Async"),
  Time = c(perf_sync$elapsed, perf_async$elapsed)
)

ggplot(perf_data, aes(x = Mode, y = Time, fill = Mode)) +
  geom_col(width = 0.6) +
  geom_text(aes(label = sprintf("%.2f sec", Time)),
            vjust = -0.5, size = 5, fontface = "bold") +
  scale_fill_manual(values = c("Sync" = "#e74c3c", "Async" = "#27ae60")) +
  labs(
    title = "Asynchronous vs Synchronous Execution Time",
    subtitle = sprintf("Speedup: %.2fx faster with parallel workers", speedup),
    x = NULL,
    y = "Elapsed Time (seconds)"
  ) +
  theme_minimal() +
  theme(
    legend.position = "none",
    plot.title = element_text(face = "bold", hjust = 0.5, size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 12, color = "#27ae60"),
    axis.title.y = element_text(face = "bold"),
    axis.text.x = element_text(size = 12, face = "bold")
  )
```

### Key Benefits of Async Execution

1. **Reduced wall-clock time**: Parallel workers execute walker steps concurrently
2. **Better resource utilization**: Takes advantage of multi-core processors
3. **Scalability**: Performance improvement increases with more walkers and larger grids
4. **Identical results**: Same stochastic behavior, just faster execution

# Pipeline Telemetry

## Pipeline Dependency Network

The targets pipeline structure showing dependencies between computation targets:

```{r pipeline-viz, fig.width=12, fig.height=8, fig.cap="Pipeline dependency graph showing target relationships and execution flow", echo=FALSE}
# Generate pipeline visualization after targets are computed
# Cannot be stored as a target due to recursion issues
# HTML widget rendered directly in the document
targets::tar_visnetwork(
  targets_only = TRUE,
  label = c("time", "size", "branches"),
  reporter = "silent"
)
```

This visualization shows:
- **Nodes**: Each target in the pipeline
- **Edges**: Dependencies between targets
- **Colors**: Target status (up-to-date, outdated, or failed)
- **Labels**: Computation time and object size

## Target Execution Statistics

This section visualizes the targets pipeline performance, showing computation time and memory usage for each target.

### Telemetry Summary Table

```{r telemetry-table}
# Collect telemetry directly from tar_meta() after pipeline completion
meta <- targets::tar_meta()

telemetry <- meta %>%
  filter(!is.na(seconds)) %>%
  select(name, seconds, bytes, warnings, error) %>%
  mutate(
    time_formatted = sprintf("%.2f sec", seconds),
    memory_mb = round(bytes / (1024^2), 2),
    status = case_when(
      !is.na(error) ~ "error",
      warnings > 0 ~ "warning",
      TRUE ~ "success"
    )
  ) %>%
  arrange(desc(seconds))

telemetry %>%
  select(name, time_formatted, memory_mb, status) %>%
  rename(
    "Target Name" = name,
    "Computation Time" = time_formatted,
    "Memory (MB)" = memory_mb,
    "Status" = status
  ) %>%
  kable(
    caption = "Target Pipeline Execution Summary",
    align = c("l", "r", "r", "c")
  )
```

**Key metrics**:

- **Target Name**: The name of each target in the pipeline
- **Computation Time**: Time taken to execute each target (in seconds)
- **Memory (MB)**: Memory usage for storing each target's output
- **Status**: Execution status (success, warning, or error)

### Computation Time by Target

```{r plot-timing, fig.cap="Computation time for each target in the pipeline"}
telemetry %>%
  filter(status == "success") %>%
  ggplot(aes(x = reorder(name, seconds), y = seconds)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  labs(
    title = "Target Pipeline: Computation Time by Target",
    x = "Target Name",
    y = "Time (seconds)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5)
  )
```

Targets with longer computation times may benefit from caching or optimization.

### Memory Usage by Target

```{r plot-memory, fig.cap="Memory usage for each target in the pipeline"}
telemetry %>%
  filter(status == "success", memory_mb > 0) %>%
  ggplot(aes(x = reorder(name, memory_mb), y = memory_mb)) +
  geom_col(fill = "coral") +
  coord_flip() +
  labs(
    title = "Target Pipeline: Memory Usage by Target",
    x = "Target Name",
    y = "Memory (MB)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5)
  )
```

Targets with high memory usage may need data compression or storage optimization.

# System Information

## R Session Information

```{r session-info}
sess_info <- tar_read(session_info)
print(sess_info)
```

## Git/GitHub Summary

```{r git-info}
git_info <- tar_read(git_summary)

# Handle all fields defensively - ensure single values
branch_text <- if (length(git_info$branch) > 0) git_info$branch[1] else "unknown"
commit_text <- if (length(git_info$commit) > 0) git_info$commit[1] else "unknown"
remote_text <- if (length(git_info$remote) > 0) basename(git_info$remote[1]) else "unknown"
status_text <- if (length(git_info$status) == 0) {
  "Clean"
} else {
  paste0(length(git_info$status), " file(s) modified")
}

data.frame(
  Field = c("Branch", "Commit", "Remote", "Status"),
  Value = c(branch_text, commit_text, remote_text, status_text),
  stringsAsFactors = FALSE
) %>%
  kable(caption = "Git Repository Information")
```

# Pipeline Reproducibility

All objects displayed in this vignette are pre-computed and stored in the targets pipeline. To reproduce these results:

1. Ensure you have the required packages installed (see DESCRIPTION)
2. Run `targets::tar_make()` in the package root directory
3. Render this vignette to see the updated results

```{r, eval=FALSE, echo=TRUE}
# Reproduce the pipeline
targets::tar_make()

# View the pipeline
targets::tar_visnetwork()

# Check target status
targets::tar_meta()
```

# Summary

This telemetry vignette provides comprehensive statistics about the `randomwalk` package pipeline:

- **Package metadata**: Version and description information
- **Example simulations**: Demonstration of package functionality
- **Pipeline performance**: Execution time and memory usage per target
- **System information**: R session and platform details
- **Reproducibility**: Version control and dependency tracking

All statistics are generated automatically from the targets pipeline, ensuring consistency and reproducibility across package builds.

---

*Generated on: `r Sys.time()`*

*Using targets pipeline from: `_targets.R`*

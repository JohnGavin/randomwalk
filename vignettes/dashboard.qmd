---
title: "Interactive Dashboard"
format:
  html:
    code-fold: true
    code-summary: "Show code"
    toc: true
    toc-depth: 3
runtime: shiny
server: shiny
execute:
  eval: true
  echo: true
  warning: false
  message: false
---

# Random Walk Simulation Dashboard

This vignette provides an **interactive Shiny application** embedded directly in the page. Use the controls below to configure simulation parameters and visualize results in real-time.

## Interactive Simulation

The dashboard below allows you to:

- Configure grid size, number of walkers, and other parameters
- Choose neighborhood type (4-hood or 8-hood) and boundary behavior
- Run simulations and see results immediately
- Explore multiple visualization tabs

```{r}
#| context: setup
library(randomwalk)
library(shiny)
library(ggplot2)
```

```{r}
#| panel: sidebar

sliderInput(
  "grid_size",
  "Grid Size:",
  min = 3,
  max = 100,
  value = 20,
  step = 1
)

sliderInput(
  "n_walkers",
  "Number of Walkers:",
  min = 1,
  max = 10,
  value = 5,
  step = 1
)

selectInput(
  "neighborhood",
  "Neighborhood Type:",
  choices = c("4-hood" = "4-hood", "8-hood" = "8-hood"),
  selected = "4-hood"
)

selectInput(
  "boundary",
  "Boundary Behavior:",
  choices = c("Terminate" = "terminate", "Wrap" = "wrap"),
  selected = "terminate"
)

sliderInput(
  "max_steps",
  "Max Steps:",
  min = 100,
  max = 50000,
  value = 10000,
  step = 100
)

checkboxInput(
  "verbose",
  "Verbose Output",
  value = FALSE
)

hr()

actionButton(
  "run_sim",
  "Run Simulation",
  class = "btn-primary",
  width = "100%"
)

actionButton(
  "reset",
  "Reset Parameters",
  class = "btn-secondary",
  width = "100%",
  style = "margin-top: 10px;"
)

# Update max walkers based on grid size
observe({
  max_walkers <- floor(input$grid_size * input$grid_size * 0.6)
  updateSliderInput(
    session,
    "n_walkers",
    max = max_walkers,
    value = min(input$n_walkers, max_walkers)
  )
})

# Reset button handler
observeEvent(input$reset, {
  updateSliderInput(session, "grid_size", value = 20)
  updateSliderInput(session, "n_walkers", value = 5)
  updateSelectInput(session, "neighborhood", selected = "4-hood")
  updateSelectInput(session, "boundary", selected = "terminate")
  updateSliderInput(session, "max_steps", value = 10000)
  updateCheckboxInput(session, "verbose", value = FALSE)
})
```

```{r}
#| panel: fill

# Reactive simulation result
sim_result <- eventReactive(input$run_sim, {
  withProgress(message = 'Running simulation...', value = 0, {
    incProgress(0.3, detail = "Setting up grid")

    result <- run_simulation(
      grid_size = input$grid_size,
      n_walkers = input$n_walkers,
      neighborhood = input$neighborhood,
      boundary = input$boundary,
      max_steps = input$max_steps,
      verbose = input$verbose
    )

    incProgress(0.7, detail = "Complete")
    result
  })
})

# Create tabset panel for outputs
tabsetPanel(
  id = "output_tabs",
  type = "tabs",

  # Grid State Tab
  tabPanel(
    "Grid State",
    br(),
    plotOutput("grid_plot", height = "600px")
  ),

  # Walker Paths Tab
  tabPanel(
    "Walker Paths",
    br(),
    plotOutput("paths_plot", height = "600px")
  ),

  # Statistics Tab
  tabPanel(
    "Statistics",
    br(),
    h4("Simulation Statistics"),
    verbatimTextOutput("stats_text"),
    hr(),
    h4("Parameters Used"),
    tableOutput("params_table")
  ),

  # Raw Data Tab
  tabPanel(
    "Raw Data",
    br(),
    h4("Walker Data"),
    tableOutput("walker_table"),
    hr(),
    h4("Grid Information"),
    verbatimTextOutput("grid_info")
  )
)

# Render grid plot
output$grid_plot <- renderPlot({
  req(sim_result())
  plot_grid(sim_result())
})

# Render paths plot
output$paths_plot <- renderPlot({
  req(sim_result())
  plot_paths(sim_result())
})

# Render statistics
output$stats_text <- renderText({
  req(sim_result())
  stats <- sim_result()$statistics
  paste(format_statistics(stats), collapse = "\n")
})

# Render parameters table
output$params_table <- renderTable({
  req(sim_result())
  params <- sim_result()$parameters
  data.frame(
    Parameter = c("Grid Size", "Walkers", "Neighborhood", "Boundary", "Max Steps"),
    Value = c(
      params$grid_size,
      params$n_walkers,
      params$neighborhood,
      params$boundary,
      params$max_steps
    )
  )
})

# Render walker table
output$walker_table <- renderTable({
  req(sim_result())
  walkers <- sim_result()$walkers

  data.frame(
    Walker = sapply(walkers, function(w) w$id),
    Steps = sapply(walkers, function(w) w$steps),
    Final_X = sapply(walkers, function(w) w$pos[1]),
    Final_Y = sapply(walkers, function(w) w$pos[2]),
    Status = sapply(walkers, function(w) ifelse(w$active, "Active", "Terminated")),
    Reason = sapply(walkers, function(w) w$termination_reason)
  )
})

# Render grid info
output$grid_info <- renderText({
  req(sim_result())
  grid <- sim_result()$grid
  stats <- sim_result()$statistics

  paste(
    sprintf("Grid dimensions: %d x %d", nrow(grid), ncol(grid)),
    sprintf("Total pixels: %d", nrow(grid) * ncol(grid)),
    sprintf("Black pixels: %d (%.2f%%)", stats$black_pixels, stats$black_percentage),
    sprintf("White pixels: %d", nrow(grid) * ncol(grid) - stats$black_pixels),
    sep = "\n"
  )
})
```

## How to Use

1. **Adjust Parameters** in the left sidebar:
   - **Grid Size**: Larger grids create more complex patterns
   - **Number of Walkers**: More walkers increase coverage
   - **Neighborhood**: 8-hood creates denser patterns than 4-hood
   - **Boundary**: Wrap creates toroidal topology, terminate stops at edges

2. **Click "Run Simulation"** to execute with current parameters

3. **Explore Results** across four tabs:
   - **Grid State**: Final black pixel pattern
   - **Walker Paths**: Individual walker trajectories
   - **Statistics**: Quantitative metrics
   - **Raw Data**: Detailed walker and grid information

4. **Use "Reset Parameters"** to return to defaults

## Technical Details

### Architecture

The simulation uses a modular architecture:

- **Core Engine** (`run_simulation()`): Pure R logic, no GUI dependencies
- **Shiny Interface**: This embedded app provides interactive access
- **Visualization** (`plot_grid()`, `plot_paths()`): Reusable plotting functions

### Parameters

**Grid Size** (3-100): Defines the N×N grid dimensions. Larger grids allow for more complex fractal patterns but take longer to simulate.

**Number of Walkers** (1 to 60% of grid capacity): Each walker performs a random walk until termination. Maximum is dynamically adjusted based on grid size to prevent overcrowding.

**Neighborhood Type**:
- **4-hood**: Walkers move to 4 adjacent cells (up, down, left, right)
- **8-hood**: Walkers move to 8 cells (including diagonals)

**Boundary Behavior**:
- **Terminate**: Walkers stop when reaching grid edge
- **Wrap**: Edges connect (toroidal topology)

**Max Steps**: Safety limit to prevent infinite loops

### Termination Conditions

Walkers stop when:
1. Adjacent to a black pixel (deposits own black pixel)
2. Hitting boundary (if terminate mode)
3. Reaching maximum steps
4. No valid moves available

## Performance Notes

- Simulations typically complete in under 1 second for grids up to 50×50
- Larger grids (75-100) may take several seconds
- Progress indicator shows simulation status
- Results are cached until parameters change

## Related Functions

For programmatic use outside this dashboard:

```r
# Run simulation directly
result <- run_simulation(
  grid_size = 30,
  n_walkers = 10,
  neighborhood = "8-hood",
  boundary = "wrap"
)

# Create visualizations
plot_grid(result)
plot_paths(result)

# Access statistics
result$statistics

# Launch standalone dashboard
run_dashboard()
```

## References

- Package documentation: `?run_simulation`
- Module documentation: `?run_dashboard`
- Source code: GitHub repository

---
title: "Async/Parallel Simulation Dashboard"
format:
  html:
    code-fold: true
    code-summary: "Show code"
    toc: true
    toc-depth: 3
    embed-resources: false
filters:
  - shinylive
---

# Async Random Walk Simulation Dashboard

This vignette provides a **fully interactive async/parallel Shiny application** that runs directly in your browser using WebAssembly. Test parallel execution with multiple workers!

## Overview

The async dashboard demonstrates the **parallel processing capabilities** of the `randomwalk` package using the `crew` package for worker management. The simulation runs entirely client-side using WebAssembly technology.

### Key Features

- **Parallel Execution**: Choose 0-4 workers for sync or async mode
- **Performance Metrics**: Compare execution time with different worker counts
- **Real-time Visualization**: View grid state, walker paths, and statistics
- **No Server Required**: Runs entirely in your browser via WebAssembly
- **Package Integration**: Uses the actual `randomwalk` package async functions

### Async vs Sync Mode

- **Sync Mode** (`workers = 0`): Sequential processing, predictable results
- **Async Mode** (`workers > 0`): Parallel processing using `crew` workers
  - Workers process walkers independently
  - Potential speedup with multiple CPU cores
  - Results may differ slightly (workers use static grid snapshots)

## Interactive Async Dashboard

Use the controls below to configure simulation parameters and test async performance:

```{shinylive-r}
#| standalone: true
#| viewerHeight: 900

# Mount WebAssembly file system from GitHub release
webr::mount(
  mountpoint = "/randomwalk-lib",
  source = "https://github.com/JohnGavin/randomwalk/releases/latest/download/library.data"
)

# Add mounted library to library paths
.libPaths(c("/randomwalk-lib", .libPaths()))

# Load required packages
library(shiny)
library(ggplot2)

# Load randomwalk from mounted library
library(randomwalk)

# Define UI
ui <- fluidPage(
  titlePanel("Async Random Walk Simulation Dashboard"),

  sidebarLayout(
    # Sidebar with input controls
    sidebarPanel(
      width = 3,

      h4("Simulation Parameters"),
      p("Configure the random walk simulation parameters below."),

      hr(),

      # ASYNC PARAMETER - Number of workers
      sliderInput(
        "workers",
        "Number of Workers:",
        min = 0,
        max = 4,
        value = 2,
        step = 1,
        ticks = FALSE
      ),
      helpText(
        HTML("<b>0 = Sync mode</b> (sequential)<br>",
             "<b>1+ = Async mode</b> (parallel)<br>",
             "More workers may improve performance")
      ),

      sliderInput(
        "grid_size",
        "Grid Size:",
        min = 5,
        max = 50,
        value = 20,
        step = 1,
        ticks = FALSE
      ),
      helpText("Size of the square grid (5-50)"),

      sliderInput(
        "n_walkers",
        "Number of Walkers:",
        min = 1,
        max = 20,
        value = 6,
        step = 1,
        ticks = FALSE
      ),
      helpText("Number of simultaneous random walkers (1-20)"),

      selectInput(
        "neighborhood",
        "Neighborhood Type:",
        choices = c(
          "4-neighborhood (N, S, E, W)" = "4-hood",
          "8-neighborhood (incl. diagonals)" = "8-hood"
        ),
        selected = "4-hood"
      ),

      selectInput(
        "boundary",
        "Boundary Behavior:",
        choices = c(
          "Terminate at edge" = "terminate",
          "Wrap around (torus)" = "wrap"
        ),
        selected = "terminate"
      ),

      sliderInput(
        "max_steps",
        "Max Steps per Walker:",
        min = 1000,
        max = 20000,
        value = 10000,
        step = 1000,
        ticks = FALSE
      ),
      helpText("Maximum steps before walker stops (1k-20k)"),

      hr(),

      actionButton(
        "run_sim",
        "Run Simulation",
        class = "btn-primary btn-lg",
        width = "100%",
        icon = icon("play")
      ),

      br(), br(),

      actionButton(
        "reset",
        "Reset to Defaults",
        class = "btn-secondary",
        width = "100%",
        icon = icon("rotate-left")
      ),

      hr(),

      # Status display
      div(
        id = "status_box",
        style = "padding: 10px; border-radius: 5px; background-color: #f8f9fa;",
        h5("Status", style = "margin-top: 0;"),
        textOutput("status_text")
      )
    ),

    # Main panel with tabbed output
    mainPanel(
      width = 9,

      tabsetPanel(
        id = "output_tabs",
        type = "pills",

        # Performance Tab (NEW for async)
        tabPanel(
          "Performance",
          icon = icon("gauge-high"),
          br(),
          h4("Async Performance Metrics"),
          p("Compare execution time between sync and async modes."),
          tableOutput("perf_table"),
          hr(),
          h5("Execution Mode"),
          p(textOutput("mode_info")),
          hr(),
          h5("Performance Analysis"),
          p(textOutput("perf_analysis"))
        ),

        # Grid State Tab
        tabPanel(
          "Grid State",
          icon = icon("table-cells"),
          br(),
          h4("Final Grid Visualization"),
          p("Black squares represent pixels visited by random walkers."),
          plotOutput("grid_plot", height = "600px"),
          hr(),
          p(class = "text-muted", "Generated using plot_grid() from the randomwalk package")
        ),

        # Walker Paths Tab
        tabPanel(
          "Walker Paths",
          icon = icon("route"),
          br(),
          h4("Individual Walker Trajectories"),
          p("Green squares mark starting positions, red squares show where walkers terminated."),
          plotOutput("paths_plot", height = "600px"),
          hr(),
          p(class = "text-muted", "Generated using plot_walker_paths() from the randomwalk package")
        ),

        # Statistics Tab
        tabPanel(
          "Statistics",
          icon = icon("chart-line"),
          br(),
          h4("Simulation Metrics"),
          tableOutput("stats_table"),
          hr(),
          h5("Coverage Analysis"),
          p(textOutput("coverage_analysis")),
          hr(),
          h5("Walker Summary"),
          tableOutput("walker_summary")
        ),

        # Raw Data Tab
        tabPanel(
          "Raw Data",
          icon = icon("database"),
          br(),
          h4("Detailed Walker Information"),
          p("Complete data for each walker in the simulation."),
          dataTableOutput("walker_data"),
          hr(),
          h4("Grid Information"),
          tableOutput("grid_info")
        ),

        # About Tab
        tabPanel(
          "About",
          icon = icon("info-circle"),
          br(),
          h4("About This Async Dashboard"),
          p("This interactive dashboard demonstrates the randomwalk package's async/parallel capabilities using crew workers and WebAssembly."),

          h5("How Async Mode Works"),
          tags$ul(
            tags$li(strong("Sync Mode (workers=0):"), " Walkers processed sequentially"),
            tags$li(strong("Async Mode (workers>0):"), " Walkers processed in parallel by crew workers"),
            tags$li(strong("Static Snapshots:"), " Workers use frozen grid state (no real-time sync)"),
            tags$li(strong("Independent Execution:"), " Each worker processes walkers independently")
          ),

          h5("Expected Performance"),
          tags$ul(
            tags$li("1 worker: Similar to sync mode"),
            tags$li("2 workers: ~1.5x speedup (target)"),
            tags$li("4 workers: ~2-3x speedup (depends on workload)"),
            tags$li("Speedup limited by walker termination times and overhead")
          ),

          h5("Trade-offs"),
          tags$ul(
            tags$li(tags$b("Pro:"), " Faster execution with multiple workers"),
            tags$li(tags$b("Pro:"), " Simple, reliable architecture"),
            tags$li(tags$b("Con:"), " Results may differ from sync mode (acceptable)"),
            tags$li(tags$b("Con:"), " Workers don't see real-time updates from other workers")
          ),

          h5("References"),
          tags$ul(
            tags$li(tags$a(href = "https://github.com/JohnGavin/randomwalk", "randomwalk GitHub Repository")),
            tags$li(tags$a(href = "https://wlandau.github.io/crew/", "crew: A Distributed Worker Launcher")),
            tags$li(tags$a(href = "https://posit-dev.github.io/r-shinylive/", "Shinylive Documentation"))
          )
        )
      )
    )
  )
)

# Define server logic
server <- function(input, output, session) {

  # Reactive value to store simulation result
  sim_result <- reactiveVal(NULL)

  # Reactive value for status messages
  status_msg <- reactiveVal("Ready to run simulation")

  # Run simulation when button clicked
  observeEvent(input$run_sim, {
    mode_text <- if (input$workers == 0) "sync" else sprintf("async (%d workers)", input$workers)
    status_msg(sprintf("Running simulation in %s mode...", mode_text))

    tryCatch({
      # Validate inputs
      if (input$n_walkers > (0.6 * input$grid_size^2)) {
        showNotification(
          "Too many walkers for grid size. Maximum is 60% of grid cells.",
          type = "warning",
          duration = 5
        )
        status_msg("Error: Too many walkers for grid size")
        return(NULL)
      }

      # Run the simulation using randomwalk package with workers parameter
      result <- randomwalk::run_simulation(
        grid_size = input$grid_size,
        n_walkers = input$n_walkers,
        workers = input$workers,        # ASYNC PARAMETER
        neighborhood = input$neighborhood,
        boundary = input$boundary,
        max_steps = input$max_steps,
        verbose = FALSE
      )

      # Store result
      sim_result(result)

      # Update status
      status_msg(sprintf(
        "Simulation complete (%s mode)! %d steps, %.1f%% coverage in %.2fs",
        mode_text,
        result$statistics$total_steps,
        result$statistics$black_percentage,
        result$statistics$elapsed_time_secs
      ))

      # Show success notification
      showNotification(
        sprintf("Simulation completed in %.2f seconds!", result$statistics$elapsed_time_secs),
        type = "message",
        duration = 3
      )

    }, error = function(e) {
      status_msg(paste("Error:", e$message))
      showNotification(
        paste("Simulation failed:", e$message),
        type = "error",
        duration = 10
      )
    })
  })

  # Reset parameters
  observeEvent(input$reset, {
    updateSliderInput(session, "workers", value = 2)
    updateSliderInput(session, "grid_size", value = 20)
    updateSliderInput(session, "n_walkers", value = 6)
    updateSelectInput(session, "neighborhood", selected = "4-hood")
    updateSelectInput(session, "boundary", selected = "terminate")
    updateSliderInput(session, "max_steps", value = 10000)
    status_msg("Parameters reset to defaults")

    showNotification(
      "Parameters reset to default values",
      type = "message",
      duration = 2
    )
  })

  # Render status text
  output$status_text <- renderText({
    status_msg()
  })

  # ASYNC PERFORMANCE TABLE
  output$perf_table <- renderTable({
    req(sim_result())
    stats <- sim_result()$statistics
    params <- sim_result()$parameters

    data.frame(
      Metric = c(
        "Execution Mode",
        "Number of Workers",
        "Elapsed Time",
        "Total Steps",
        "Steps per Second",
        "Black Pixels Created"
      ),
      Value = c(
        ifelse(params$workers == 0, "Sync (Sequential)", sprintf("Async (Parallel - %d workers)", params$workers)),
        params$workers,
        sprintf("%.3f seconds", stats$elapsed_time_secs),
        format(stats$total_steps, big.mark = ","),
        format(round(stats$total_steps / stats$elapsed_time_secs), big.mark = ","),
        stats$black_pixels
      )
    )
  }, striped = TRUE, hover = TRUE, bordered = TRUE)

  # Mode information
  output$mode_info <- renderText({
    req(sim_result())
    params <- sim_result()$parameters

    if (params$workers == 0) {
      "Running in SYNC mode: Walkers are processed sequentially in round-robin fashion. This produces deterministic, reproducible results."
    } else {
      sprintf(
        "Running in ASYNC mode with %d worker%s: Walkers are distributed across parallel workers. Workers use static grid snapshots, so results may differ from sync mode. This is expected behavior.",
        params$workers,
        ifelse(params$workers == 1, "", "s")
      )
    }
  })

  # Performance analysis
  output$perf_analysis <- renderText({
    req(sim_result())
    stats <- sim_result()$statistics
    params <- sim_result()$parameters

    if (params$workers == 0) {
      sprintf(
        "Sync mode completed %d walkers in %.3f seconds (%.1f walkers/second). To test async performance, increase the number of workers and re-run.",
        stats$total_walkers,
        stats$elapsed_time_secs,
        stats$total_walkers / stats$elapsed_time_secs
      )
    } else {
      # Estimate theoretical speedup (actual depends on walker termination patterns)
      theoretical_speedup <- min(params$workers, stats$total_walkers)

      sprintf(
        "Async mode with %d workers completed %d walkers in %.3f seconds. Theoretical maximum speedup is %.1fx (limited by %d workers and %d walkers). Actual speedup depends on walker termination patterns and parallelization overhead. Try comparing with sync mode (workers=0) to measure actual speedup.",
        params$workers,
        stats$total_walkers,
        stats$elapsed_time_secs,
        theoretical_speedup,
        params$workers,
        stats$total_walkers
      )
    }
  })

  # Render grid plot
  output$grid_plot <- renderPlot({
    req(sim_result())
    randomwalk::plot_grid(sim_result())
  })

  # Render walker paths plot
  output$paths_plot <- renderPlot({
    req(sim_result())
    randomwalk::plot_walker_paths(sim_result())
  })

  # Render statistics table
  output$stats_table <- renderTable({
    req(sim_result())
    stats <- sim_result()$statistics

    data.frame(
      Metric = c(
        "Total Steps",
        "Final Black Pixels",
        "Final Black Percentage",
        "Grid Size",
        "Number of Walkers",
        "Elapsed Time (sec)"
      ),
      Value = c(
        format(stats$total_steps, big.mark = ","),
        format(stats$black_pixels, big.mark = ","),
        sprintf("%.2f%%", stats$black_percentage),
        sprintf("%d × %d", stats$grid_size, stats$grid_size),
        stats$total_walkers,
        sprintf("%.3f", stats$elapsed_time_secs)
      )
    )
  }, striped = TRUE, hover = TRUE, bordered = TRUE)

  # Coverage analysis text
  output$coverage_analysis <- renderText({
    req(sim_result())
    stats <- sim_result()$statistics

    total_cells <- stats$grid_size^2
    black_cells <- stats$black_pixels
    coverage_pct <- stats$black_percentage

    sprintf(
      "The simulation covered %d out of %d grid cells (%.2f%%). On average, %.1f steps were taken per black pixel created.",
      black_cells,
      total_cells,
      coverage_pct,
      stats$total_steps / black_cells
    )
  })

  # Walker summary table
  output$walker_summary <- renderTable({
    req(sim_result())
    walkers <- sim_result()$walkers

    data.frame(
      Statistic = c(
        "Total Walkers",
        "Average Steps",
        "Min Steps",
        "Max Steps",
        "Completed Walkers"
      ),
      Value = c(
        length(walkers),
        sprintf("%.1f", mean(sapply(walkers, function(w) w$steps))),
        min(sapply(walkers, function(w) w$steps)),
        max(sapply(walkers, function(w) w$steps)),
        sum(sapply(walkers, function(w) !w$active))
      )
    )
  }, striped = TRUE, hover = TRUE, bordered = TRUE)

  # Walker data table
  output$walker_data <- renderDataTable({
    req(sim_result())
    walkers <- sim_result()$walkers

    # Format for display
    walkers_display <- data.frame(
      Walker = sapply(walkers, function(w) w$id),
      Steps = sapply(walkers, function(w) w$steps),
      Start_X = sapply(walkers, function(w) w$path[[1]][1]),
      Start_Y = sapply(walkers, function(w) w$path[[1]][2]),
      End_X = sapply(walkers, function(w) tail(w$path[[1]], 1)[1]),
      End_Y = sapply(walkers, function(w) tail(w$path[[1]], 1)[2]),
      Active = sapply(walkers, function(w) ifelse(w$active, "Yes", "No")),
      Reason = sapply(walkers, function(w) w$termination_reason)
    )

    walkers_display
  }, options = list(
    pageLength = 10,
    scrollX = TRUE,
    dom = 'tip'
  ))

  # Grid info table
  output$grid_info <- renderTable({
    req(sim_result())
    stats <- sim_result()$statistics
    params <- sim_result()$parameters

    data.frame(
      Property = c(
        "Grid Dimensions",
        "Total Cells",
        "Black Cells",
        "White Cells",
        "Neighborhood Type",
        "Boundary Behavior",
        "Execution Mode"
      ),
      Value = c(
        sprintf("%d × %d", stats$grid_size, stats$grid_size),
        format(stats$grid_size^2, big.mark = ","),
        format(stats$black_pixels, big.mark = ","),
        format(stats$grid_size^2 - stats$black_pixels, big.mark = ","),
        input$neighborhood,
        input$boundary,
        ifelse(params$workers == 0, "Sync", sprintf("Async (%d workers)", params$workers))
      )
    )
  }, striped = TRUE, hover = TRUE, bordered = TRUE)
}

# Run the application
shinyApp(ui = ui, server = server)
```

## Architecture

The async dashboard extends the sync dashboard with parallel processing capabilities:

### Async Parameters

- **Number of Workers**: 0-4 workers
  - **0 workers** = Sync mode (baseline for comparison)
  - **1+ workers** = Async mode (parallel execution)
  - More workers may improve performance (up to CPU core limit)

### Async Execution Model

1. **Worker Initialization**: `crew` spawns requested number of R worker processes
2. **Task Distribution**: Walkers distributed across workers
3. **Independent Processing**: Each worker processes assigned walkers using static grid snapshot
4. **Result Collection**: Main process collects completed walker results
5. **Resource Cleanup**: Workers terminated after simulation completes

### Performance Metrics

The **Performance tab** shows:
- Execution mode (sync vs async)
- Number of workers used
- Elapsed time
- Steps per second throughput
- Performance analysis and speedup estimation

## Usage Examples

### Testing Async Performance

1. **Baseline**: Run with `workers = 0` (sync mode)
2. **Note timing**: Check elapsed time in Performance tab
3. **Scale up**: Increase workers to 2, then 4
4. **Compare**: Observe speedup in Performance tab

### Optimal Worker Count

- **Small simulations**: 1-2 workers (overhead dominates)
- **Medium simulations**: 2-4 workers (good speedup)
- **Large simulations**: 4+ workers (max speedup)
- **Rule of thumb**: Don't exceed number of CPU cores

### Expected Results

- **Sync vs Async**: Results may differ (static snapshots)
- **Speedup**: Typically 1.5-2x with 2 workers
- **Variability**: Speedup depends on walker termination patterns
- **Overhead**: Some overhead from worker management

## Technical Details

### Static Snapshot Architecture

Workers operate on **frozen grid state**:

**Pros**:
- ✅ No serialization issues
- ✅ Simple, reliable implementation
- ✅ Fast worker execution

**Cons**:
- ⚠️ Workers don't see real-time updates
- ⚠️ Results may differ from sync mode
- ⚠️ Some walker interactions missed

### Why Results Differ

**Sync mode example**:
1. Walker A terminates at (5,5) → pixel becomes black
2. Walker B sees black pixel at (5,5)
3. Walker B terminates early when near (5,5)
4. Result: 2 black pixels

**Async mode example**:
1. Worker 1: Walker A terminates at (5,5)
2. Worker 2: Walker B doesn't see (5,5) is black
3. Walker B continues until termination at (7,8)
4. Result: 3 black pixels

This is **expected behavior** and doesn't indicate a bug.

## See Also

- `vignette("dashboard")` - Sync-only dashboard
- `vignette("telemetry")` - Pipeline statistics
- `?run_simulation` - Core simulation function (workers parameter)
- [crew Package](https://wlandau.github.io/crew/) - Distributed worker launcher

## Summary

This async dashboard provides:

- **Parallel Execution**: Test async performance with multiple workers
- **Performance Metrics**: Compare sync vs async timing
- **Interactive Testing**: Adjust worker count in real-time
- **Educational**: Understand async/parallel random walks
- **Production-Ready**: Uses the actual async implementation from randomwalk package

The async implementation uses static grid snapshots for simplicity and reliability, trading real-time synchronization for predictable, robust parallel execution.

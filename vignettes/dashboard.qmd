---
title: "Interactive Dashboard"
format:
  html:
    code-fold: true
    code-summary: "Show code"
    toc: true
    toc-depth: 3
execute:
  eval: true
  echo: true
  warning: false
  message: false
---

# Random Walk Simulation Dashboard

This vignette describes the interactive Shiny dashboard for exploring random walk simulations. The dashboard provides a user-friendly interface for configuring simulation parameters, running simulations, and visualizing results.

## Quick Start

Launch the interactive dashboard with:

```{r}
#| eval: false
library(randomwalk)
run_dashboard()
```

The dashboard will open in your default web browser with a fully interactive interface.

## Dashboard Overview

The dashboard is built using Shiny modules to maintain clean separation between:

- **Input controls**: Parameter configuration (grid size, walkers, neighborhood type, etc.)
- **Simulation engine**: Core random walk logic (independent of GUI)
- **Output displays**: Visualization and tabulation of results

This modular architecture ensures the simulation code remains reusable outside the dashboard context.

## Features

### 1. Parameter Configuration Panel

The left sidebar provides interactive controls for all simulation parameters:

- **Grid Size** (3-100): Defines the N×N grid dimensions
- **Number of Walkers** (dynamically limited to 60% of grid capacity)
- **Neighborhood Type**: Choose between 4-hood or 8-hood
- **Boundary Behavior**: Terminate at edges or wrap (toroidal topology)
- **Maximum Steps**: Safety limit to prevent infinite loops
- **Verbose Logging**: Optional detailed output

Dynamic validation ensures parameters stay within valid ranges. For example, the maximum number of walkers automatically adjusts when you change the grid size.

### 2. Multiple Output Views

Results are displayed across four tabs:

**Grid State Tab**: Visualizes the final grid showing black pixels that formed during the simulation.

**Walker Paths Tab**: Shows individual walker trajectories, termination points, and path colors to distinguish between walkers.

**Statistics Tab**: Displays comprehensive metrics including:
- Black pixel count and percentage
- Walker statistics (total, completed, active)
- Step statistics (min, max, mean, median, quartiles)
- Elapsed time
- Termination reason breakdown

**Raw Data Tab**: Provides detailed tables with:
- Walker-level data (ID, steps, final position, status, termination reason)
- Grid information (dimensions, pixel counts)

### 3. Interactive Controls

- **Run Simulation**: Execute simulation with current parameters
- **Reset Parameters**: Return all controls to default values

## Example Usage

Here's a programmatic example showing how to use the simulation functions that power the dashboard:

```{r}
library(randomwalk)

# Run simulation with custom parameters
result <- run_simulation(
  grid_size = 30,
  n_walkers = 10,
  neighborhood = "8-hood",
  boundary = "wrap",
  max_steps = 10000,
  verbose = FALSE
)

# View statistics
result$statistics
```

```{r}
#| fig-width: 8
#| fig-height: 8

# Create visualizations
plot_grid(result)
```

```{r}
#| fig-width: 8
#| fig-height: 8

plot_walker_paths(result)
```

## Parameter Effects

### Grid Size

Larger grids create more complex fractal patterns but take longer to simulate:

- **Small (3-20)**: Fast execution, simple patterns
- **Medium (20-50)**: Balanced complexity and speed
- **Large (50-100)**: Complex patterns, longer execution time

### Number of Walkers

More walkers increase grid coverage and pattern density:

- **Few (1-5)**: Sparse patterns, faster execution
- **Many (10+)**: Dense patterns, slower but more interesting results

The dashboard automatically limits walkers to 60% of grid capacity to prevent overcrowding.

### Neighborhood Type

**4-hood** (von Neumann neighborhood):
- Walkers move to 4 adjacent cells (up, down, left, right)
- Creates more linear, cross-like patterns
- Generally produces sparser structures

**8-hood** (Moore neighborhood):
- Walkers move to 8 adjacent cells (including diagonals)
- Creates denser, more clustered patterns
- Results in more filled regions

### Boundary Behavior

**Terminate**:
- Walkers stop when reaching the grid edge
- Edge pixels remain white
- Suitable for studying bounded growth

**Wrap**:
- Edges connect (toroidal topology)
- No boundary constraints
- Creates more uniform pattern distribution

## Termination Conditions

Walkers stop when encountering any of these conditions:

1. **Adjacent to black pixel**: Walker deposits its black pixel and terminates
2. **Hit boundary** (terminate mode only): Walker reaches grid edge
3. **Maximum steps reached**: Safety limit exceeded
4. **No valid moves**: All adjacent cells are black (rare)

The Statistics tab shows the distribution of termination reasons for your simulation.

## Technical Architecture

### Module Structure

The dashboard uses three main Shiny modules:

**sim_input_ui() / sim_input_server()**:
- Input controls and validation
- Returns reactive parameters and run trigger
- Handles parameter reset logic

**sim_output_ui() / sim_output_server()**:
- Tabbed output interface
- Renders plots, tables, and statistics
- Accepts simulation results as reactive input

**run_dashboard()**:
- Combines input and output modules
- Manages reactive flow
- Launches Shiny app

Example of programmatic module usage:

```{r}
#| eval: false

library(shiny)
library(randomwalk)

# Using modules in a custom app
ui <- fluidPage(
  titlePanel("Custom Random Walk App"),
  sidebarLayout(
    sidebarPanel(sim_input_ui("inputs")),
    mainPanel(sim_output_ui("outputs"))
  )
)

server <- function(input, output, session) {
  inputs <- sim_input_server("inputs")

  sim_result <- eventReactive(inputs$run_trigger(), {
    params <- inputs$params()
    do.call(run_simulation, params)
  })

  sim_output_server("outputs", sim_result)
}

shinyApp(ui, server)
```

### Separation of Concerns

The dashboard architecture maintains clear boundaries:

**GUI Layer** (R/shiny_modules.R):
- Input widgets and event handling
- Output rendering and formatting
- Shiny-specific reactivity

**Simulation Layer** (R/random_walk.R):
- Pure R logic, no GUI dependencies
- Accepts parameters, returns results
- Can be used independently in scripts, pipelines, or other GUIs

**Visualization Layer** (R/plotting.R):
- Reusable ggplot2 functions
- Work with simulation results
- Independent of Shiny context

This design allows you to:
- Run simulations in batch scripts
- Use the simulation in targets pipelines
- Create custom visualizations
- Build alternative GUIs (e.g., command-line interface)

## Performance Considerations

Typical execution times (synchronous mode):

- **Grid 10×10, 5 walkers**: < 0.1 seconds
- **Grid 30×30, 10 walkers**: 0.2-0.5 seconds
- **Grid 50×50, 20 walkers**: 1-3 seconds
- **Grid 100×100, 40 walkers**: 5-15 seconds

The dashboard includes a progress indicator for longer simulations.

For large-scale parameter sweeps or batch processing, use the simulation functions directly rather than the interactive dashboard.

## Advanced Usage

### Custom Visualization

Create your own plots using simulation results:

```{r}
#| eval: false
library(ggplot2)

# Run simulation
result <- run_simulation(grid_size = 40, n_walkers = 15)

# Custom heatmap showing pixel values
grid_df <- as.data.frame(as.table(result$grid))
names(grid_df) <- c("x", "y", "value")

ggplot(grid_df, aes(x = x, y = y, fill = factor(value))) +
  geom_tile() +
  scale_fill_manual(values = c("white", "black")) +
  coord_equal() +
  theme_minimal() +
  theme(legend.position = "none")
```

### Integration with targets Pipeline

The simulation functions work seamlessly with the targets package:

```{r}
#| eval: false
library(targets)

# In _targets.R
list(
  tar_target(
    sim_result,
    run_simulation(
      grid_size = 50,
      n_walkers = 20,
      neighborhood = "8-hood",
      boundary = "wrap"
    )
  ),
  tar_target(grid_plot, plot_grid(sim_result)),
  tar_target(paths_plot, plot_walker_paths(sim_result))
)
```

### Batch Parameter Exploration

Run multiple simulations with varying parameters:

```{r}
#| eval: false
library(purrr)

# Parameter grid
params <- expand.grid(
  grid_size = c(20, 30, 40),
  n_walkers = c(5, 10, 15),
  neighborhood = c("4-hood", "8-hood")
)

# Run all combinations
results <- pmap(params, function(grid_size, n_walkers, neighborhood) {
  run_simulation(
    grid_size = grid_size,
    n_walkers = n_walkers,
    neighborhood = neighborhood,
    boundary = "terminate"
  )
})

# Extract statistics
stats_df <- map_dfr(results, ~as.data.frame(.x$statistics))
```

## Testing

The dashboard modules include comprehensive test coverage:

- UI element generation tests
- Server reactivity tests
- Input validation tests
- Output rendering tests
- Integration tests

Run tests with:

```{r}
#| eval: false
devtools::test()
```

## Troubleshooting

**Dashboard doesn't launch**:
- Ensure shiny package is installed: `install.packages("shiny")`
- Check that port 3838 is available
- Try specifying a different port: `run_dashboard(port = 8080)`

**Simulation takes too long**:
- Reduce grid size or number of walkers
- Check verbose mode is disabled
- Consider running programmatically for large parameters

**Plots don't render**:
- Ensure ggplot2 is installed
- Check simulation completed successfully
- Verify result object has expected structure

## Related Documentation

- **Simulation Core**: `?run_simulation` - Main simulation function
- **Plotting**: `?plot_grid`, `?plot_walker_paths` - Visualization functions
- **Modules**: `?run_dashboard` - Dashboard launcher
- **Package Overview**: `?randomwalk` - Package documentation

## References

For more information on the underlying concepts:

- Random walk algorithms and fractal generation
- Shiny modules and reactive programming
- ggplot2 visualization techniques
- targets pipeline integration

Launch the dashboard now and start exploring:

```{r}
#| eval: false
run_dashboard()
```

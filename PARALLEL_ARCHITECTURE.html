<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Parallel &amp; Async Architecture - Random Walk Simulation • randomwalk</title><script src="deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="deps/headroom-0.11.0/headroom.min.js"></script><script src="deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="deps/search-1.0.0/fuse.min.js"></script><script src="deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="pkgdown.js"></script><meta property="og:title" content="Parallel &amp; Async Architecture - Random Walk Simulation"></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-primary" data-bs-theme="dark" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="index.html">randomwalk</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">2.0.0.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="nav-item"><a class="nav-link" href="reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles"><li><a class="dropdown-item" href="articles/dashboard/">Interactive Dashboard (Sync)</a></li>
    <li><a class="dropdown-item" href="articles/dashboard_async/">Async/Parallel Dashboard</a></li>
    <li><a class="dropdown-item" href="articles/telemetry.html">Telemetry and Pipeline Statistics</a></li>
  </ul></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="search.json"></form></li>
      </ul></div>


  </div>
</nav><div class="container template-title-body">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Parallel &amp; Async Architecture - Random Walk Simulation</h1>

    </div>

<div id="parallel--async-architecture---random-walk-simulation" class="section level1">

<p><strong>Status</strong>: Designed but <strong>Not Yet Implemented</strong> in v1.0.0 <strong>Current Mode</strong>: Synchronous only (single-threaded)</p>
<div class="section level2">
<h2 id="important-notice">Important Notice<a class="anchor" aria-label="anchor" href="#important-notice"></a></h2>
<p>⚠️ <strong>The current v1.0.0 implementation is SYNCHRONOUS only</strong> despite the title claiming “Asynchronous Pixel Walking.”</p>
<p>Looking at the actual code in <code>R/simulation.R</code>:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Line 11: workers parameter exists but is not used</span></span>
<span><span class="co"># Line 12: Note: Async implementation not yet available in this version.</span></span>
<span><span class="co"># Line 69: Mode: Synchronous (hardcoded)</span></span></code></pre></div>
<p>The package <strong>describes</strong> an async architecture but <strong>has not implemented</strong> it yet. The DESCRIPTION and documentation reference the intended design, but the code runs serially.</p>
</div>
<div class="section level2">
<h2 id="intended-architecture-not-yet-built">Intended Architecture (Not Yet Built)<a class="anchor" aria-label="anchor" href="#intended-architecture-not-yet-built"></a></h2>
<p>Based on <code>prompt_random_walk.md</code>, here’s the <strong>planned</strong> parallel architecture:</p>
<div class="section level3">
<h3 id="components">Components<a class="anchor" aria-label="anchor" href="#components"></a></h3>
<ol style="list-style-type: decimal"><li>
<strong>Main Process</strong>
<ul><li>Shiny app with UI</li>
<li>Simulation management and coordination</li>
<li>Results aggregation</li>
</ul></li>
<li>
<strong>Worker Processes</strong> (using <code>crew</code> package)
<ul><li>Independent R processes</li>
<li>Each manages one walker at a time</li>
<li>Work queue for walker assignment</li>
</ul></li>
<li>
<strong>Communication</strong> (using <code>nanonext</code> package)
<ul><li>Push/Pull sockets for job distribution</li>
<li>Publisher/Subscriber for state synchronization</li>
<li>Ports: 5555, 5556, 5557, 5558</li>
</ul></li>
<li>
<strong>State Management</strong> (using <code>duckdb</code> package)
<ul><li>In-memory DuckDB database</li>
<li>Global grid state shared across workers</li>
<li>Real-time state synchronization</li>
</ul></li>
</ol></div>
<div class="section level3">
<h3 id="how-parallelization-would-work">How Parallelization Would Work<a class="anchor" aria-label="anchor" href="#how-parallelization-would-work"></a></h3>
<div class="section level4">
<h4 id="walker-distribution">Walker Distribution<a class="anchor" aria-label="anchor" href="#walker-distribution"></a></h4>
<pre><code>Controller Queue: [Walker1, Walker2, Walker3, ... Walker8]
                         ↓          ↓          ↓
                    Worker1     Worker2    Worker3</code></pre>
<ul><li>
<strong>Workers</strong>: 3 parallel R processes</li>
<li>
<strong>Walkers</strong>: 8 total (queued for processing)</li>
<li>Each worker processes walkers independently</li>
<li>When a walker terminates, worker picks next from queue</li>
</ul></div>
<div class="section level4">
<h4 id="state-synchronization-flow">State Synchronization Flow<a class="anchor" aria-label="anchor" href="#state-synchronization-flow"></a></h4>
<pre><code>Worker1: Walker terminates → Updates DuckDB → Broadcasts to all
Worker2: Receives broadcast → Updates local cache → Continues
Worker3: Receives broadcast → Updates local cache → Continues</code></pre>
<p><strong>Key Mechanism</strong>: - Every walker checks global state <strong>before every move</strong> - If grid updated, worker fetches latest from DuckDB - Prevents walkers from stepping on newly-black pixels</p>
</div>
</div>
<div class="section level3">
<h3 id="parallelization-benefits-theoretical">Parallelization Benefits (Theoretical)<a class="anchor" aria-label="anchor" href="#parallelization-benefits-theoretical"></a></h3>
<div class="section level4">
<h4 id="what-gets-parallelized">What Gets Parallelized<a class="anchor" aria-label="anchor" href="#what-gets-parallelized"></a></h4>
<ol style="list-style-type: decimal"><li>
<strong>Walker Movement</strong> - Each walker runs independently:
<ul><li>Compute next position</li>
<li>Check boundary conditions</li>
<li>Detect termination</li>
<li>Update path history</li>
</ul></li>
<li>
<strong>Collision Detection</strong> - Workers check grid independently:
<ul><li>Each maintains local black pixel cache</li>
<li>Checks for black neighbors</li>
<li>Updates on global state changes</li>
</ul></li>
<li>
<strong>Statistics Collection</strong> - Workers track locally:
<ul><li>Step counts</li>
<li>Path trajectories</li>
<li>Termination reasons</li>
</ul></li>
</ol></div>
<div class="section level4">
<h4 id="what-remains-serial">What Remains Serial<a class="anchor" aria-label="anchor" href="#what-remains-serial"></a></h4>
<ol style="list-style-type: decimal"><li>
<strong>Grid State Updates</strong> - Must be synchronized:
<ul><li>When walker terminates and pixel turns black</li>
<li>Broadcast to all workers</li>
<li>All workers must receive update</li>
</ul></li>
<li>
<strong>Global Statistics Aggregation</strong> - Done by controller:
<ul><li>Collect results from all workers</li>
<li>Compute percentiles across all walkers</li>
<li>Final grid state assembly</li>
</ul></li>
</ol></div>
</div>
<div class="section level3">
<h3 id="expected-speedup-theoretical-estimates">Expected Speedup (Theoretical Estimates)<a class="anchor" aria-label="anchor" href="#expected-speedup-theoretical-estimates"></a></h3>
<p>Based on the parallel design, here are <strong>estimated</strong> speedups:</p>
<div class="section level4">
<h4 id="ideal-case-cpu-bound-work-no-contention">Ideal Case (CPU-bound work, no contention)<a class="anchor" aria-label="anchor" href="#ideal-case-cpu-bound-work-no-contention"></a></h4>
<table class="table"><thead><tr><th>Workers</th>
<th>Walkers</th>
<th>Expected Speedup</th>
<th>Reason</th>
</tr></thead><tbody><tr><td>1</td>
<td>8</td>
<td>1.0x (baseline)</td>
<td>Serial execution</td>
</tr><tr><td>2</td>
<td>8</td>
<td>~1.8x</td>
<td>Near-linear, some sync overhead</td>
</tr><tr><td>3</td>
<td>8</td>
<td>~2.5x</td>
<td>Good parallelism, moderate overhead</td>
</tr><tr><td>4</td>
<td>8</td>
<td>~3.0x</td>
<td>Diminishing returns start</td>
</tr><tr><td>8</td>
<td>8</td>
<td>~4.0x</td>
<td>Heavy sync overhead</td>
</tr></tbody></table><p><strong>Why not 8x with 8 workers?</strong> - Grid state synchronization overhead - DuckDB lock contention - nanonext communication latency - Worker startup/shutdown costs</p>
</div>
<div class="section level4">
<h4 id="realistic-case-with-sync-overhead">Realistic Case (with sync overhead)<a class="anchor" aria-label="anchor" href="#realistic-case-with-sync-overhead"></a></h4>
<p>Assuming each walker takes 1000 steps: - <strong>Computation</strong>: 900 steps (90%) - can parallelize - <strong>Synchronization</strong>: 100 steps (10%) - must serialize</p>
<p><strong>Amdahl’s Law</strong>: <code>Speedup = 1 / (0.1 + 0.9/N)</code></p>
<table class="table"><thead><tr><th>Workers</th>
<th>Theoretical Max</th>
<th>Expected Reality</th>
</tr></thead><tbody><tr><td>2</td>
<td>1.82x</td>
<td>~1.5-1.7x</td>
</tr><tr><td>4</td>
<td>3.08x</td>
<td>~2.2-2.8x</td>
</tr><tr><td>8</td>
<td>5.26x</td>
<td>~3.0-4.0x</td>
</tr><tr><td>16</td>
<td>8.11x</td>
<td>~4.0-5.5x</td>
</tr></tbody></table><p><strong>Reality factors</strong>: - Cache invalidation when state updates - Network latency (even local sockets) - Database query overhead - R process communication costs</p>
</div>
</div>
<div class="section level3">
<h3 id="bottlenecks-in-parallel-design">Bottlenecks in Parallel Design<a class="anchor" aria-label="anchor" href="#bottlenecks-in-parallel-design"></a></h3>
<ol style="list-style-type: decimal"><li>
<strong>Global State Updates</strong>
<ul><li>Every walker termination requires broadcast</li>
<li>All workers must receive and acknowledge</li>
<li>Can stall fast walkers waiting for slow workers</li>
</ul></li>
<li>
<strong>DuckDB Contention</strong>
<ul><li>Read/write locks on grid state table</li>
<li>Multiple workers querying simultaneously</li>
<li>INSERT operations block readers</li>
</ul></li>
<li>
<strong>Communication Overhead</strong>
<ul><li>nanonext socket latency (~1-10ms per message)</li>
<li>Serialization/deserialization of grid state</li>
<li>Broadcast amplification (1→N messages)</li>
</ul></li>
<li>
<strong>Cache Coherency</strong>
<ul><li>Each worker maintains local black pixel cache</li>
<li>Must invalidate and refresh on every broadcast</li>
<li>Memory bandwidth limitation</li>
</ul></li>
</ol></div>
<div class="section level3">
<h3 id="performance-optimizations-planned">Performance Optimizations (Planned)<a class="anchor" aria-label="anchor" href="#performance-optimizations-planned"></a></h3>
<p>From <code>prompt_random_walk.md</code>:</p>
<ol style="list-style-type: decimal"><li>
<strong>Batched Updates</strong>
<ul><li>Don’t broadcast every single pixel change</li>
<li>Batch multiple terminations</li>
<li>Periodic sync intervals</li>
</ul></li>
<li>
<strong>Local Caching</strong>
<ul><li>Workers maintain black pixel cache</li>
<li>Only refresh on explicit updates</li>
<li>Fast neighbor checking</li>
</ul></li>
<li>
<strong>Non-blocking Communication</strong>
<ul><li>Workers don’t wait for ACK</li>
<li>Continue processing with stale state</li>
<li>Accept “approximate” synchronization</li>
</ul></li>
<li>
<strong>Smart Work Distribution</strong>
<ul><li>Queue prioritizes walkers by position</li>
<li>Spread walkers across grid regions</li>
<li>Minimize contention hotspots</li>
</ul></li>
</ol></div>
<div class="section level3">
<h3 id="approximate-vs-exact-simulation">Approximate vs Exact Simulation<a class="anchor" aria-label="anchor" href="#approximate-vs-exact-simulation"></a></h3>
<p><strong>Key Trade-off</strong> (from prompt_random_walk.md lines 88-96):</p>
<blockquote>
<p>“the simulation is an approximation in async mode cos the global updates are nearly in real time but real time is not guaranted.”</p>
</blockquote>
<p><strong>Sync Mode (1 worker)</strong>: - ✅ Exact: Global state always current - ❌ Slow: Serial execution - Use case: Small grids, accuracy critical</p>
<p><strong>Async Mode (2+ workers)</strong>: - ✅ Fast: Parallel execution - ⚠️ Approximate: State updates lag - Use case: Large grids, speed matters</p>
<p><strong>The Approximation</strong>:</p>
<pre><code>Timeline:
t=0: Worker1 walker terminates, pixel turns black
t=1: Worker1 broadcasts update
t=2: Worker2 receives update (but moved 2 steps with stale state!)
t=3: Worker2 updates cache, continues with current state</code></pre>
<p>Between t=0 and t=2, Worker2 operated with outdated grid state. This could cause: - Walking onto a black pixel that should have stopped it - Slightly different paths than pure serial simulation - Different random walk trajectory</p>
<p><strong>This is acceptable</strong> because: - Random walks are stochastic anyway - Statistical properties converge - Speedup outweighs small inaccuracies - Final patterns are “close enough”</p>
</div>
</div>
<div class="section level2">
<h2 id="example-simulation-timeline-theoretical">Example Simulation Timeline (Theoretical)<a class="anchor" aria-label="anchor" href="#example-simulation-timeline-theoretical"></a></h2>
<div class="section level3">
<h3 id="sync-mode-1-worker-8-walkers">Sync Mode (1 worker, 8 walkers)<a class="anchor" aria-label="anchor" href="#sync-mode-1-worker-8-walkers"></a></h3>
<pre><code>Step 1: Walker 1 moves (10ms)
Step 2: Walker 2 moves (10ms)
Step 3: Walker 3 moves (10ms)
...
Step 8: Walker 8 moves (10ms)
Total per round: 80ms</code></pre>
</div>
<div class="section level3">
<h3 id="async-mode-3-workers-8-walkers">Async Mode (3 workers, 8 walkers)<a class="anchor" aria-label="anchor" href="#async-mode-3-workers-8-walkers"></a></h3>
<pre><code>Step 1: [Worker1: W1 moves | Worker2: W2 moves | Worker3: W3 moves] (10ms)
Step 2: [Worker1: W4 moves | Worker2: W5 moves | Worker3: W6 moves] (10ms)
Step 3: [Worker1: W7 moves | Worker2: W8 moves | Worker3: idle    ] (10ms)
Total per round: 30ms
Speedup: 2.67x</code></pre>
</div>
<div class="section level3">
<h3 id="with-synchronization-overhead">With Synchronization Overhead<a class="anchor" aria-label="anchor" href="#with-synchronization-overhead"></a></h3>
<pre><code>Async with sync:
Step 1: [W1, W2, W3 move in parallel] (10ms)
        W1 terminates → broadcast (5ms) → all workers update (2ms)
Step 2: [W4, W5, W6 move] (10ms)
Total per round: ~40-50ms
Speedup: 1.6-2.0x (realistic)</code></pre>
</div>
</div>
<div class="section level2">
<h2 id="current-implementation-v100">Current Implementation (v1.0.0)<a class="anchor" aria-label="anchor" href="#current-implementation-v100"></a></h2>
<p><strong>What actually exists</strong>:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># R/simulation.R lines 85-121</span></span>
<span><span class="kw">while</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/any.html" class="external-link">any</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">sapply</a></span><span class="op">(</span><span class="va">walkers</span>, <span class="kw">function</span><span class="op">(</span><span class="va">w</span><span class="op">)</span> <span class="va">w</span><span class="op">$</span><span class="va">active</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq_along</a></span><span class="op">(</span><span class="va">walkers</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span>  <span class="co"># Serial loop - no parallelism!</span></span>
<span>    <span class="va">walker</span> <span class="op">&lt;-</span> <span class="va">walkers</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span></span>
<span>    <span class="kw">if</span> <span class="op">(</span><span class="op">!</span><span class="va">walker</span><span class="op">$</span><span class="va">active</span><span class="op">)</span> <span class="kw">next</span></span>
<span></span>
<span>    <span class="va">walker</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/step_walker.html">step_walker</a></span><span class="op">(</span><span class="va">walker</span>, <span class="va">...</span><span class="op">)</span></span>
<span>    <span class="va">walker</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/check_termination.html">check_termination</a></span><span class="op">(</span><span class="va">walker</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span>    <span class="kw">if</span> <span class="op">(</span><span class="op">!</span><span class="va">walker</span><span class="op">$</span><span class="va">active</span><span class="op">)</span> <span class="op">{</span></span>
<span>      <span class="va">grid</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/set_pixel_black.html">set_pixel_black</a></span><span class="op">(</span><span class="va">grid</span>, <span class="va">walker</span><span class="op">$</span><span class="va">pos</span>, <span class="va">boundary</span><span class="op">)</span></span>
<span>    <span class="op">}</span></span>
<span></span>
<span>    <span class="va">walkers</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">walker</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>This is a <strong>simple serial loop</strong> processing walkers one at a time. No parallelism whatsoever.</p>
</div>
<div class="section level2">
<h2 id="why-async-not-implemented">Why Async Not Implemented<a class="anchor" aria-label="anchor" href="#why-async-not-implemented"></a></h2>
<p>Looking at DESCRIPTION:</p>
<pre><code>Suggests:
    duckdb,
    nanonext,</code></pre>
<p>These are in <strong>Suggests</strong>, not <strong>Imports</strong>, meaning: - Optional dependencies - Not required for core functionality - Likely not implemented yet</p>
<p>The v1.0.0 release focused on: 1. Getting the basic simulation working 2. Creating the Shinylive dashboard 3. Resolving deployment issues</p>
<p>The parallel/async architecture is <strong>future work</strong>.</p>
</div>
<div class="section level2">
<h2 id="summary">Summary<a class="anchor" aria-label="anchor" href="#summary"></a></h2>
<div class="section level3">
<h3 id="what-v100-has">What v1.0.0 Has<a class="anchor" aria-label="anchor" href="#what-v100-has"></a></h3>
<ul><li>✅ Basic random walk simulation (works correctly)</li>
<li>✅ Shinylive browser dashboard (fully functional)</li>
<li>✅ Grid visualization and statistics</li>
<li>✅ Multiple walkers (processed serially)</li>
<li>✅ Comprehensive documentation</li>
</ul></div>
<div class="section level3">
<h3 id="what-v100-lacks">What v1.0.0 Lacks<a class="anchor" aria-label="anchor" href="#what-v100-lacks"></a></h3>
<ul><li>❌ Parallel worker processes (crew)</li>
<li>❌ Async communication (nanonext)</li>
<li>❌ Shared state database (DuckDB)</li>
<li>❌ Real-time synchronization</li>
<li>❌ Actual speedup from parallelism</li>
</ul></div>
<div class="section level3">
<h3 id="future-work-for-v200">Future Work for v2.0.0<a class="anchor" aria-label="anchor" href="#future-work-for-v200"></a></h3>
<p>To implement the planned architecture:</p>
<ol style="list-style-type: decimal"><li>
<strong>Add crew for worker management</strong>
<ul><li>Move crew from Suggests to Imports</li>
<li>Implement worker pool initialization</li>
<li>Add work queue and task distribution</li>
</ul></li>
<li>
<strong>Add nanonext for communication</strong>
<ul><li>Set up pub/sub pattern for state broadcasts</li>
<li>Implement push/pull for job distribution</li>
<li>Handle socket lifecycle</li>
</ul></li>
<li>
<strong>Add DuckDB for state</strong>
<ul><li>Create in-memory database schema</li>
<li>Implement grid state table</li>
<li>Add concurrent read/write handling</li>
</ul></li>
<li>
<strong>Implement synchronization</strong>
<ul><li>State update broadcasts</li>
<li>Local cache invalidation</li>
<li>Periodic sync intervals</li>
</ul></li>
<li>
<strong>Add performance benchmarks</strong>
<ul><li>Measure actual speedups</li>
<li>Compare sync vs async modes</li>
<li>Tune batch sizes and sync intervals</li>
</ul></li>
</ol></div>
<div class="section level3">
<h3 id="estimated-implementation-effort">Estimated Implementation Effort<a class="anchor" aria-label="anchor" href="#estimated-implementation-effort"></a></h3>
<ul><li>
<strong>Small (1-2 weeks)</strong>: Basic parallel execution with crew</li>
<li>
<strong>Medium (3-4 weeks)</strong>: Add state sync with DuckDB</li>
<li>
<strong>Large (2-3 months)</strong>: Full async architecture with all optimizations</li>
</ul></div>
</div>
<div class="section level2">
<h2 id="conclusion">Conclusion<a class="anchor" aria-label="anchor" href="#conclusion"></a></h2>
<p>The random walk package has a well-designed parallel architecture <strong>on paper</strong>, but v1.0.0 implements <strong>only the serial version</strong>. The title “Asynchronous Pixel Walking” describes the <strong>intended</strong> future state, not the current implementation.</p>
<p>The current Shinylive dashboard works perfectly for demonstrating the simulation concept, but runs synchronously in the browser (which is fine for small grids and few walkers).</p>
<p>For production use with large grids and many walkers, the async architecture would need to be implemented to achieve meaningful speedups.</p>
</div>
</div>

  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by John Gavin.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer></div>





  </body></html>

